// src/controllers/sourcingController.ts
import { Request, Response } from "express";
import prisma from "../utils/prismaClient";
import logger from "../utils/logger";
import * as Sentry from "@sentry/node";
import { GlobalSetting, SourcingStatus } from "@prisma/client";

/**
 * A helper function to get settings from the DB
 */
const getSettings = (settings: GlobalSetting[]) => {
  const settingsMap = new Map(settings.map((s) => [s.key, parseFloat(s.value)]));
  return {
    CONTINGENCY_FEE_RATE: settingsMap.get("CONTINGENCY_FEE_RATE") || 0.02,
    // We add a default insurance rate for the estimator
    DEFAULT_MARINE_INSURANCE_RATE: settingsMap.get("DEFAULT_MARINE_INSURANCE_RATE") || 0.01,
  };
};

/**
 * User: Creates a simple "product request"
 */
export const createSourcingRequest = async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user.id;
    const { productDescription } = req.body;

    const request = await prisma.sourcingRequest.create({
      data: {
        userId,
        productDescription,
        status: SourcingStatus.PENDING,
      },
    });
    res.status(201).json({ success: true, data: request });
  } catch (error: any) {
    logger.error("Error creating sourcing request:", error);
    Sentry.captureException(error);
    res.status(500).json({ success: false, message: error.message });
  }
};

/**
 * User: Calculates an estimated landed cost and logs it as a sourcing request.
 */
export const estimateLandedCost = async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user.id;
    const { productDescription, basePrice, hsCode } = req.body;

    // 1. Fetch KRA Rate and Settings in parallel
    const [kraRate, globalSettings] = await prisma.$transaction([
      prisma.kRARate.findFirstOrThrow({
        where: { hsCode: { startsWith: hsCode } },
        orderBy: { effectiveFrom: "desc" },
      }),
      prisma.globalSetting.findMany({
        where: { key: { in: ["CONTINGENCY_FEE_RATE", "DEFAULT_MARINE_INSURANCE_RATE"] } },
      }),
    ]);

    const settings = getSettings(globalSettings);

    // 2. Calculate variable costs (based on adminPoolController logic)
    const cost = basePrice;
    const insurance = cost * settings.DEFAULT_MARINE_INSURANCE_RATE;
    const cif_per_unit = cost + insurance;

    const importDuty = cif_per_unit * kraRate.duty_rate;
    const idf = cif_per_unit * kraRate.idf_rate;
    const rdl = cif_per_unit * kraRate.rdl_rate;
    const vatBase = cif_per_unit + importDuty + idf + rdl;
    const vat = vatBase * kraRate.vat_rate;
    const taxes_per_unit = importDuty + idf + rdl + vat;
    
    // This is the total cost *before* contingency
    const totalVariableCostPerUnit = cost + taxes_per_unit + insurance;

    // 3. Add contingency to get the final benchmark price
    const estimatedBenchmarkPrice = totalVariableCostPerUnit * (1 + settings.CONTINGENCY_FEE_RATE);

    // 4. Log this calculation as a SourcingRequest for the admin
    await prisma.sourcingRequest.create({
      data: {
        userId,
        productDescription,
        status: SourcingStatus.RESEARCHING, // Mark for research
        hsCode: hsCode,
        basePrice: basePrice, // The user's guessed price
        benchmarkPrice: Math.ceil(estimatedBenchmarkPrice), // The calculated price
        notes: "Generated by user's Landed Cost Estimator."
      },
    });

    // 5. Return the result to the user
    res.status(200).json({
      success: true,
      data: {
        estimatedLandedCost: Math.ceil(estimatedBenchmarkPrice),
        basePrice: cost,
        taxes: Math.ceil(taxes_per_unit),
        insurance: Math.ceil(insurance),
        contingency: Math.ceil(totalVariableCostPerUnit * settings.CONTINGENCY_FEE_RATE),
        message: "This is an estimate. The final group-buy price may be lower."
      },
    });

  } catch (error: any) {
    logger.error("Error in estimateLandedCost:", error);
    Sentry.captureException(error);
    if (error.name === 'NotFoundError' || error.code === 'P2025') {
      return res.status(404).json({ 
        success: false, 
        message: "Could not find a valid KRA tax rate for the provided HS code." 
      });
    }
    res.status(500).json({ success: false, message: error.message });
  }
};

/**
 * Admin: Get all sourcing requests
 */
export const getAllSourcingRequests = async (req: Request, res: Response) => {
  try {
    const requests = await prisma.sourcingRequest.findMany({
      include: {
        user: { select: { name: true, email: true } },
      },
      orderBy: { createdAt: "desc" },
    });
    res.status(200).json({ success: true, data: requests });
  } catch (error: any) {
    logger.error("Error fetching sourcing requests:", error);
    Sentry.captureException(error);
    res.status(500).json({ success: false, message: error.message });
  }
};

/**
 * Admin: Update a request with research
 */
export const updateSourcingRequest = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const {
      status,
      notes,
      hsCode,
      basePrice,
      benchmarkPrice,
    } = req.body;

    const request = await prisma.sourcingRequest.update({
      where: { id },
      data: {
        status,
        notes,
        hsCode,
        basePrice: basePrice ? parseFloat(basePrice) : undefined,
        benchmarkPrice: benchmarkPrice ? parseFloat(benchmarkPrice) : undefined,
      },
    });
    res.status(200).json({ success: true, data: request });
  } catch (error: any) {
    logger.error("Error updating sourcing request:", error);
    Sentry.captureException(error);
    if ((error as any).code === "P2025") {
      return res.status(404).json({ success: false, message: "Request not found" });
    }
    res.status(500).json({ success: false, message: error.message });
  }
};