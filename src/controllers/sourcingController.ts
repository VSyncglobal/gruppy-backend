// src/controllers/sourcingController.ts
import { Request, Response } from "express";
import prisma from "../utils/prismaClient";
import logger from "../utils/logger";
import * as Sentry from "@sentry/node";
import { GlobalSetting, SourcingStatus } from "@prisma/client";

/**
 * --- MODIFIED (v_phase6): Uses new margin keys ---
 * A helper function to get settings from the DB
 */
const getSettings = (settings: GlobalSetting[]) => {
  const settingsMap = new Map(settings.map((s) => [s.key, parseFloat(s.value)]));
  return {
    // Use new, clearer margin keys
    RISK_MARGIN: settingsMap.get("RISK_MARGIN") || 0.02,
    PLATFORM_MARGIN: settingsMap.get("PLATFORM_MARGIN") || 0.05,
    DEFAULT_MARINE_INSURANCE_RATE:
      settingsMap.get("DEFAULT_MARINE_INSURANCE_RATE") || 0.01,
  };
};

/**
 * User: Creates a simple "product request"
 * (Unchanged)
 */
export const createSourcingRequest = async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user.id;
    const { productDescription } = req.body;

    const request = await prisma.sourcingRequest.create({
      data: {
        userId,
        productDescription,
        status: SourcingStatus.PENDING,
      },
    });
    res.status(201).json({ success: true, data: request });
  } catch (error: any) {
    logger.error("Error creating sourcing request:", error);
    Sentry.captureException(error);
    res.status(500).json({ success: false, message: error.message });
  }
};

/**
 * --- MODIFIED (v_phase6): Updated to use new profit model ---
 * User: Calculates an estimated landed cost and logs it as a sourcing request.
 */
export const estimateLandedCost = async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user.id;
    const { productDescription, basePrice, hsCode } = req.body;

    // 1. Fetch KRA Rate and Settings in parallel
    const [kraRate, globalSettings] = await prisma.$transaction([
      prisma.kRARate.findFirstOrThrow({
        where: { hsCode: { startsWith: hsCode } },
        orderBy: { effectiveFrom: "desc" },
      }),
      // --- MODIFIED (v_phase6): Fetches new margin keys ---
      prisma.globalSetting.findMany({
        where: {
          key: {
            in: [
              "RISK_MARGIN",
              "PLATFORM_MARGIN",
              "DEFAULT_MARINE_INSURANCE_RATE",
            ],
          },
        },
      }),
    ]);

    const settings = getSettings(globalSettings);

    // 2. Calculate variable costs (based on adminPoolController logic)
    // NOTE: This estimate does *not* include fixed freight costs,
    // as we don't know the target quantity.
    const cost = basePrice;
    const insurance = cost * settings.DEFAULT_MARINE_INSURANCE_RATE;
    const cif_per_unit = cost + insurance; // This CIF is *partial*

    const importDuty = cif_per_unit * kraRate.duty_rate;
    const idf = cif_per_unit * kraRate.idf_rate;
    const rdl = cif_per_unit * kraRate.rdl_rate;
    const vatBase = cif_per_unit + importDuty + idf + rdl;
    const vat = vatBase * kraRate.vat_rate;
    const taxes_per_unit = importDuty + idf + rdl + vat;

    // This is the total variable cost
    const totalVariableCostPerUnit = cost + taxes_per_unit + insurance;

    // 3. --- MODIFIED (v_phase6): Use new profit formula ---
    // This is the "True Landed Cost" (variable part only)
    // We apply the margins to get the final estimated price.
    const estimatedBenchmarkPrice =
      totalVariableCostPerUnit /
      (1 - settings.PLATFORM_MARGIN - settings.RISK_MARGIN);

    // 4. Log this calculation as a SourcingRequest for the admin
    await prisma.sourcingRequest.create({
      data: {
        userId,
        productDescription,
        status: SourcingStatus.RESEARCHING, // Mark for research
        hsCode: hsCode,
        basePrice: basePrice, // The user's guessed price
        benchmarkPrice: Math.ceil(estimatedBenchmarkPrice), // The calculated price
        notes: "Generated by user's Landed Cost Estimator.",
      },
    });

    // 5. Return the result to the user
    res.status(200).json({
      success: true,
      data: {
        estimatedLandedCost: Math.ceil(estimatedBenchmarkPrice),
        basePrice: cost,
        taxes: Math.ceil(taxes_per_unit),
        insurance: Math.ceil(insurance),
        // --- MODIFIED (v_phase6): Show clear margins ---
        estimatedMargins: Math.ceil(
          estimatedBenchmarkPrice - totalVariableCostPerUnit
        ),
        message:
          "This is an estimate. The final group-buy price will also include shipping and may be lower.",
      },
    });
  } catch (error: any) {
    logger.error("Error in estimateLandedCost:", error);
    Sentry.captureException(error);
    if (error.name === "NotFoundError" || error.code === "P2025") {
      return res.status(404).json({
        success: false,
        message: "Could not find a valid KRA tax rate for the provided HS code.",
      });
    }
    res.status(500).json({ success: false, message: error.message });
  }
};

/**
 * Admin: Get all sourcing requests
 * (Unchanged)
 */
export const getAllSourcingRequests = async (req: Request, res: Response) => {
  try {
    const requests = await prisma.sourcingRequest.findMany({
      include: {
        user: { select: { name: true, email: true } },
      },
      orderBy: { createdAt: "desc" },
    });
    res.status(200).json({ success: true, data: requests });
  } catch (error: any) {
    logger.error("Error fetching sourcing requests:", error);
    Sentry.captureException(error);
    res.status(500).json({ success: false, message: error.message });
  }
};

/**
 * Admin: Update a request with research
 * (Unchanged)
 */
export const updateSourcingRequest = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { status, notes, hsCode, basePrice, benchmarkPrice } = req.body;

    const request = await prisma.sourcingRequest.update({
      where: { id },
      data: {
        status,
        notes,
        hsCode,
        basePrice: basePrice ? parseFloat(basePrice) : undefined,
        benchmarkPrice: benchmarkPrice ? parseFloat(benchmarkPrice) : undefined,
      },
    });
    res.status(200).json({ success: true, data: request });
  } catch (error: any) {
    logger.error("Error updating sourcing request:", error);
    Sentry.captureException(error);
    if ((error as any).code === "P2025") {
      return res
        .status(404)
        .json({ success: false, message: "Request not found" });
    }
    res.status(500).json({ success: false, message: error.message });
  }
};

/**
 * --- NEW (v_phase6) ---
 * Admin: Delete a sourcing request
 */
export const deleteSourcingRequest = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;

    // The relation to User is onDelete: Cascade, so this is safe.
    await prisma.sourcingRequest.delete({
      where: { id },
    });

    res.status(204).send();
  } catch (error: any) {
    logger.error(`Error deleting sourcing request ${req.params.id}:`, error);
    Sentry.captureException(error);
    if ((error as any).code === "P2025") {
      return res
        .status(404)
        .json({ success: false, message: "Sourcing request not found." });
    }
    res.status(500).json({ success: false, message: error.message });
  }
};